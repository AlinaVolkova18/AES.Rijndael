Программа шифрования и расшифрования, использующая метод AES.Rijndael

Состоянием называется промежуточный результат работы алгоритма. Состояние может быть представлено как прямоугольный массив байт, содержащий 4 строки и Nb столбцов (Nb=4, 6 или 8). Для AES Nb = 4. Ключ может быть представлен как массив из четырехбайтовых слов. Ключ состоит из Nk таких слов. Каждое слово соответствует одному из столбцов (рис. 38). 
Данные открытого текста отображаются на состояние по столбцам, то есть: a0,0, a1,0, a2,0, a3,0, a0,1, … После работы алгоритма выходные данные извлекаются из состояния в том же порядке.
Количество раундов обозначается переменной r и зависит от значений Nk и Nb (табл. 29).
Для AES размер блока равен 128 битам, а размер ключа – 128, 192 или 256 битам (в зависимости от требуемой криптостойкости и скорости шифрования). 
а0,0	а0,1	а0,2	а0,3
а1,0	а1,1	а1,2	а1,3
а2,0	а2,1	а2,2	а2,3
а3,0	а3,1	а3,2	а3,3
k0,0	k0,1	k0,2	k0,3	k0,4	k0,5
k1,0	k1,1	k1,2	k1,3	k1,4	k1,5
k2,0	k2,1	k2,2	k2,3	k2,4	k2,5
k3,0	k3,1	k3,2	k3,3	k3,4	k3,5






Рис. 38. Пример состояния (Nb=4) и ключа (Nk=6)
Таблица 29. Количество раундов Rijndael
r	Nb = 4	Nb = 6	Nb = 8
Nk = 4	10	12	14
Nk = 6	12	12	14
Nk = 8	14	14	14
Шифрование
Процедура шифрования состоит из r раундов (рис. 39). 
 
Рис. 39. Шифрование AES
В каждом раунде над состоянием выполняются четыре различных преобразования, отличается только последний раунд.
Вход: Блок X, расширенный рабочий ключ W.
Выход: Блок Y.
Y  X   W0;
FOR i = 1, …, r-1 DO
Y  ByteSub( Y ); 	    // табличная подстановка
Y  ShiftRow( Y );	    // сдвиг строк
Y  MixColumn( Y ); // перемешивание столбцов
Y  Y   Wi;	    // добавление материала ключа
Y  ByteSub( Y ); 	// табличная подстановка
Y  ShiftRow( Y );	// сдвиг строк
Y  Y   Wr;		// добавление материала ключа
RETURN Y.

 Функция ByteSub
Табличная подстановка. ByteSub – это процедура нелинейной замены байтов. Замена происходит независимо для каждого байта состояния (рис. 40).


a0,0	a0,1	a0,2	a0,3
а1,0	а1,1	а1,2	а1,3
а2,0	а2,1	а2,2	а2,3
а3,0	а3,1	а3,2	а3,3
b0,0	b0,1	b0,2	b0,3
b1,0	b1,1	b1,2	b1,3
b2,0	b2,1	b2,2	b2,3
b3,0	b3,1	b3,2	b3,3





Рис. 40. Преобразование ByteSub
Таблица подстановки S-Box (табл. 30) обратима и получается в результате двух преобразований (для каждого байта от ‘00’ до ‘FF’):
1) мультипликативной инверсии в GF(28); ‘00’ отображается сам в себя:
b(x)  b-1(x) mod m(x)   (‘00’  ‘00’),
где m(x) = x8 + x4 + x3 + x + 1 – неприводимый полином, используемый в Rijndael как образующий в арифметике полиномов; инверсия вычисляется с помощью обобщенного алгоритма Евклида [8, разд. 3.3; 9, разд. 2], в котором все числа заменены на полиномы;
2) аффинного преобразования 

 
Таблица 30. S-box
63	7c	77	7b	f2	6b	6f	c5	30	01	67	2b	fe	d7	ab	76
ca	82	c9	7d	fa	59	47	f0	ad	d4	a2	af	9c	a4	72	c0
b7	fd	93	26	36	3f	f7	cc	34	a5	e5	f1	71	d8	31	15
04	c7	23	c3	18	96	05	9a	07	12	80	e2	eb	27	b2	75
09	83	2c	1a	1b	6e	5a	a0	52	3b	d6	b3	29	e3	2f	84
53	d1	00	ed	20	fc	b1	5b	6a	cb	be	39	4a	4c	58	cf
d0	ef	aa	fb	43	4d	33	85	45	f9	02	7f	50	3c	9f	a8
51	a3	40	8f	92	9d	38	f5	bc	b6	da	21	10	ff	f3	d2
cd	0c	13	ec	5f	97	44	17	c4	a7	7e	3d	64	5d	19	73
60	81	4f	dc	22	2a	90	88	46	ee	b8	14	de	5e	0b	db
e0	32	3a	0a	49	06	24	5c	c2	d3	ac	62	91	95	e4	79
e7	c8	37	6d	8d	d5	4e	a9	6c	56	f4	ea	65	7a	ae	08
ba	78	25	2e	1c	a6	b4	c6	e8	dd	74	1f	4b	bd	8b	8a
70	3e	b5	66	48	03	f6	0e	61	35	57	b9	86	c1	1d	9e
e1	f8	98	11	69	d9	8e	94	9b	1e	87	e9	ce	55	28	df
8c	a1	89	0d	bf	e6	42	68	41	99	2d	0f	b0	54	bb	16
При соблюдении принципа обратимости можно взять произвольный S-Box.
Функция ShiftRow
Процедура циклического сдвига байт влево в строках состояния (рис. 41). Строка 1 сдвигается на C1 байт, строка 2 – на C2 байт, строка 3 – на C3 байт. Значения констант берутся из табл. 31.

a0,0	a0,1	a0,2	a0,3
а1,0	а1,1	а1,2	а1,3
а2,0	а2,1	а2,2	а2,3
а3,0	а3,1	а3,2	а3,3
a0,0	a0,1	a0,2	a0,3
a1,1	a1,2	a1,3	a1,0
a2,2	a2,3	a2,0	a2,1
a3,3	a3,0	a3,1	a3,2





Рис. 41. Преобразование ShiftRow
Таблица 31. Количество битов сдвига
Nb	C1	C2	C3
4	1	2	3
6	1	2	3
8	1	3	4

Функция MixColumn
Математическое преобразование, перемешивающее данные внутри каждого столбца. Столбцы состояния представляются полиномами и умножаются в поле GF(28) по модулю x4+1 на полином c(x) = 3x3 + x2 + x + 2. Данный полином является взаимно простым с x4+1 и, следовательно, инвертируемым. Это преобразование может быть записано в виде умножения каждого столбца состояния на матрицу c(x) (рис. 42): 

b(x) = c(x)  a(x);

 

или
b0,j = 2 · a0,j    3 · a1,j    1 · a2,j    1 · a3,j ;
b1,j = 1 · a0,j    2 · a1,j    3 · a2,j    1 · a3,j ;
b2,j = 1 · a0,j    1 · a1,j    2 · a2,j    3 · a3,j ;
b3,j = 3 · a0,j    1 · a1,j    1 · a2,j    2 · a3,j .
 
Рис. 42. Преобразование MixColumn
Вычисление результирующих значений состояния выполняется по следующим правилам:
•	сложение в поле GF(28) эквивалентно операции XOR;
•	умножение на ‘01’ не меняет умножаемое;
•	умножение на ‘02’ производится по правилу: если умножаемое значение:
-	меньше ‘80’, оно сдвигается влево на 1 бит,
-	больше или равно ‘80’, оно сначала сдвигается влево на 1 бит, а затем к результату сдвига применяется операция XOR со значением ‘1b’. 
Результат может перескочить за значение ‘ff’, то есть за границы одного байта. В этом случае нужно вернуть остаток от деления результата на ‘100’.
/* Умножение двух чисел в конечном поле GF(2^8) с определяющим полиномом x^8 + x^4 + x^3 + x + 1 */
byte gmul(byte a, byte b) {
   byte p = 0;
   bool hi_bit_set;
   for(int counter = 0; counter < 8; counter++) {
      if ((b & 1) == 1) 
         p ^= a;
      hi_bit_set = (a & 0x80) != 0;
      a <<= 1;
      if (hi_bit_set) 
         a ^= 0x1b;   /* x^8 + x^4 + x^3 + x + 1 */
      b >>= 1;
   }
   return p;
}
Функция AddRoundKey
Добавление материала ключа. В этой процедуре происходит побитовое сложение по модулю 2 (XOR) текущего состояния с расширенным рабочим ключом раунда (рис. 43). Длина ключа раунда равна длине блока.

a0,0	a0,1	a0,2	a0,3
а1,0	а1,1
а1,2	а1,3
а2,0	а2,1	а2,2	а2,3
а3,0	а3,1	а3,2	а3,3
b0,0	b0,1	b0,2	b0,3
b1,0	b1,1	b1,2	b1,3
b2,0	b2,1	b2,2	b2,3
b3,0	b3,1	b3,2	b3,3






k0,0	k0,1	k0,2	k0,3
k1,0	k1,1	k1,2	k1,3
k2,0	k2,1	k2,2	k2,3
k3,0	k3,1	k3,2	k3,3





Рис. 43. Преобразование AddRoundKey
Получение расширенного ключа
Ключи раунда вычисляются из ключа шифрования. Используются две процедуры: 1) расширение ключа и 2) выборка ключа раунда. 
Полный размер ключей раунда W равен длине блока Nb, умноженной на 32 бита и на (r+1). Например, при длине блока 128 бит и 10 циклах потребуется 1408-битный рабочий ключ. Ключ шифрования K преобразуется в расширенный рабочий ключ W, состоящий из ключей раунда. 
Ключи раунда получаются следующим образом: первый ключ состоит из первых Nb слов расширенного ключа, второй – из следующих Nb слов и т.д. Первые Nk слов рабочего ключа W содержат исходный ключ шифрования, остальные получаются из предыдущих. 
Вход: Секретный ключ К из Nk слов.
Выход: Рабочий ключ W из Nb(r+1) слов.
W  K (Nk слов);
FOR i = Nk, Nk+1, …, Nb(r+1)-1 DO
	t  wi-1;
IF i mod Nk = 0 THEN
		t  SubWord( RotWord( t ) )  Rcon[ i div Nk ];
	ELSE IF Nk = 8 THEN
		t  SubWord( t );
 	wi  wi-Nk   t;
RETURN w0…w4(r+1)-1.

В данном алгоритме SubWord(t) – функция, применяющая S-box к каждому байту слова t:
[t0, t1, t2, t3]  [S[t0], S[t1], S[t2], S[t3]].
Функция RotWord(t) осуществляет циклический сдвиг слова t на один байт влево: 
[t0, t1, t2, t3]  [t1, t2, t3, t0].
Массив раундовых констант Rcon состоит из слов
Rcon[i] = [RCi, ‘00’, ‘00’, ‘00’],
где RC1 = ‘01’;
RCi = Xtime(Rcon[i-1])  (табл. 32);
Xtime – операция над многочленами, может быть реализована на байтовом уровне как сдвиг влево (без переносов) и XOR ‘1B’, если вытесненный бит (потерянный после сдвига) равен 1.
Таблица 32. Константы RCi
i	1	2	3	4	5	6	7	8	9	10
RCi	01	02	04	08	10	20	40	80	1b	36

Расшифрование
Если при шифровании поменять местами преобразования 3-го и 4-го или 5-го и 6-го шагов, то результат не изменится. Поэтому для расшифрования можно оставить ту же последовательность преобразований, что и при шифровании, но использовать обратные преобразования (рис. 44).
Вход: Блок Y, рабочий ключ W.
Выход: Блок X.
1. X  Y   Wr;
2. FOR i = r-1, …, 1 DO
3. 	X  ByteSub-1( X ); 	// табличная подстановка
4.	X  ShiftRow-1( X );	// сдвиг строк
5.         	X  MixColumn-1( X );   // перемешивание столбцов
6.	X  X   Wi;		// добавление материала ключа
7. X  ByteSub-1( X ); 	// табличная подстановка
4. X  ShiftRow-1( X );	// сдвиг строк
6. X  X   W0;		// добавление материала ключа
7. RETURN X.
 

Рис. 44. Расшифрование AES
ByteSub-1(X) – табличная замена, использующая инвертированную таблицу S-Box. 
ShiftRow-1(X) – сдвиг строк влево на соответствующее число байт. Строка 1 сдвигается на Nb-C1 байт, строка 2 – на Nb-C2 байт, строка 3 – на Nb-C3 байт (см. табл. 31).
MixColumn-1(X) аналогично MixColumn и получается в результате умножения каждого столбца на полином d(x) (обратный с(x)), определенный из выражений
(‘03’x3 + ‘01’x2 + ‘01’x + ‘02’)  d(x) = ‘01’;
d(x) =‘0B’x3 + ‘0D’x2 + ‘09’x + ‘0E’.
То есть

 

или

b0,j = 14 · a0,j    11 · a1,j    13 · a2,j      9 · a3,j;
b1,j =   9 · a0,j    14 · a1,j    11 · a2,j    13 · a3,j;
b2,j = 13 · a0,j      9 · a1,j    14 · a2,j    11 · a3,j;
b3,j = 11 · a0,j    13 · a1,j      9 · a2,j    14 · a3,j.

Операция XOR в AddRoundKey является обратимой.
Алгоритм блочного шифрования W
Алгоритм блочного шифрования W очень похож на AES (Rijndael), в разработке которого Винсент Рэймен также принимал участие.
Блок исходного текста (512 бит) представляется в виде матрицы состояния. Матрицей состояния или состоянием называется промежуточный результат работы алгоритма. Состояние может быть представлено как массив байтов, содержащий 8 строк и 8 столбцов. Данные исходного текста отображаются на состояние по строкам. После работы алгоритма выходные данные извлекаются из состояния в том же порядке.
Основной цикл шифрования имеет 10 итераций (раундов). Каждый раунд последовательно выполняет 4 преобразования (рис. 3):
•	SubBytes;
•	ShiftColumn;
•	MixRow;
•	AddRoundKey.
